// automatically generated by the FlatBuffers compiler, do not modify

package com.openmeteo.flatbuffers.forecast

import com.google.flatbuffers.kotlin.*
import kotlin.jvm.JvmInline
@Suppress("unused")
class Timeframe : Table() {

    fun init(i: Int, buffer: ReadWriteBuffer) : Timeframe = reset(i, buffer)

    /**
     * The start time of the timeframe
     */
    val time : Long get() = lookupField(4, 0L ) { bb.getLong(it + bufferPos) }

    /**
     * Interval (daily, hourly, 15_minutely...) in seconds
     */
    val interval : Int get() = lookupField(8, 0 ) { bb.getInt(it + bufferPos) }

    /**
     * Count of retrieved intervals == (nullable) values in every variable
     */
    val count : UInt get() = lookupField(10, 0u ) { bb.getUInt(it + bufferPos) }

    /**
     * List of variables with relative values
     */
    fun variables(j: Int) : com.openmeteo.flatbuffers.forecast.VariableWithValues? = variables(com.openmeteo.flatbuffers.forecast.VariableWithValues(), j)
    fun variables(obj: com.openmeteo.flatbuffers.forecast.VariableWithValues, j: Int) : com.openmeteo.flatbuffers.forecast.VariableWithValues? = lookupField(12, null ) { obj.init(indirect(vector(it) + j * 4), bb) }
    val variablesLength : Int get() = lookupField(12, 0 ) { vectorLength(it) }

    companion object {
        fun validateVersion() = VERSION_2_0_8

        fun asRoot(buffer: ReadWriteBuffer) : Timeframe = asRoot(buffer, Timeframe())
        fun asRoot(buffer: ReadWriteBuffer, obj: Timeframe) : Timeframe = obj.init(buffer.getInt(buffer.limit) + buffer.limit, buffer)


        fun createTimeframe(builder: FlatBufferBuilder, time: Long, interval: Int, count: UInt, variablesOffset: VectorOffset<com.openmeteo.flatbuffers.forecast.VariableWithValues>) : Offset<Timeframe> {
            builder.startTable(5)
            addTime(builder, time)
            addVariables(builder, variablesOffset)
            addCount(builder, count)
            addInterval(builder, interval)
            return endTimeframe(builder)
        }
        fun startTimeframe(builder: FlatBufferBuilder) = builder.startTable(5)

        fun addTime(builder: FlatBufferBuilder, time: Long) = builder.add(0, time, 0L)

        fun addInterval(builder: FlatBufferBuilder, interval: Int) = builder.add(2, interval, 0)

        fun addCount(builder: FlatBufferBuilder, count: UInt) = builder.add(3, count, 0u)

        fun addVariables(builder: FlatBufferBuilder, variables: VectorOffset<com.openmeteo.flatbuffers.forecast.VariableWithValues>) = builder.add(4, variables, 0)

        fun createVariablesVector(builder: FlatBufferBuilder, vector:com.openmeteo.flatbuffers.forecast.VariableWithValuesOffsetArray) : VectorOffset<com.openmeteo.flatbuffers.forecast.VariableWithValues> {
            builder.startVector(4, vector.size, 4)
            for (i in vector.size - 1 downTo 0) {
                builder.add(vector[i])
            }
            return builder.endVector()
        }

        fun startVariablesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)

        fun endTimeframe(builder: FlatBufferBuilder) : Offset<Timeframe> {
            val o: Offset<Timeframe> = builder.endTable()
            return o
        }
    }
}

typealias TimeframeOffsetArray = OffsetArray<Timeframe>

inline fun TimeframeOffsetArray(size: Int, crossinline call: (Int) -> Offset<Timeframe>): TimeframeOffsetArray =
    TimeframeOffsetArray(IntArray(size) { call(it).value })
